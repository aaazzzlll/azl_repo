1. instanceof
```javascript
function myInstanceof(left,right){
	//判断右侧是否为合法的构造函数，不是的话就抛出错误
	if(typeof right!=='function'||!right.prototype){
	throw new TypeError('Right-hand side of instanceof must be a constructor')
	}
	//过滤原始类型和null
	if(typeof left!=='object'||left===null)return false
	
	let proto=Object.getPrototypeOf(left)
	while(true){
		if(proto===null)return false
		if(proto===right.prototype)return true
		proto=Object.getPrototypeOf(proto)
	}
}
```

2. 数组转树
```javascript
let list = [ 
	{ id: 1, name: '部门1', pid: 0 }, 
	{ id: 2, name: '部门2', pid: 1 }, 
	{ id: 3, name: '部门3', pid: 1 }, 
	{ id: 4, name: '部门4', pid: 3 }, 
	{ id: 5, name: '部门5', pid: 4 }, 
];

function arrayToTree(list){
	const result=[]
	const map={}  //存放id到节点的映射
	
	for(const item of list){
		map[item.id]={...item,children:[]}
	}
	
	for(const item of list){
		const id=item.id
		const pid=item.pid
		const node=map[item.id]
		if(pid===0){
			//如果pid是0，说明是根节点
			result.push(node)
		}else{
			// 边界处理：如果数据有问题，parent 找不到，可以暂时忽略或作为根节点处理
			if(!node.pid)continue
			map[pid].children.push(node)
		}
	}
	
	return result
}
```

3. 防抖
使用场景：搜索框输入
```javascript
function debounce(fn,delay){
	let timer=null
	return function(...args){
		if(timer)clearTimeOut(timer)
		timer=setTimeOut(()=>{
			fn.apply(this,args)
		},delay)
	}
}
```

4. 节流
使用场景：滚动条事件
```javascript
//时间戳版：在第一次触发事件时立即执行，以后每过 delay 秒之后才执行一次，并且最后一次触发事件不会被执行
function throttle(fn,delay){
	let last=0
	return function(...args){
		const now=new Date().getTime()
		if(now-last>=delay){
			fn.apply(this,args)
			last=now
		}
	}
}

//定时器版：用户点的一瞬间没反应，此时设置了一个定时器，时间到就执行函数
function throttle(fn,delay){
	let timer=null
	
	return function(...args){
		if(timer)return
		timer=setTimeOut(()=>{
			fn.apply(this,args)
			timer=null
		},delay)
	}
}
```

“为什么要用 `fn.apply(this, args)`？”

> "因为防抖和节流函数最终是作为事件处理函数执行的。
> 1. **关于 `this`**：如果不绑定 `this`，定时器（普通函数）内部的 `this` 可能会指向 `window`（严格模式下是 `undefined`）。我们需要让 `fn` 里的 `this` 正确指向触发事件的 DOM 元素。
>     
> 2. **关于 `args`**：事件触发时会传递 `Event` 对象，我们需要用 `...args` 接收这些参数，并通过 `apply` 透传给原函数，否则原函数就拿不到 `event` 对象了。"
>

5. new
```javascript
function myNew(fn,...args){
	//Object.prototype.toString.call(fn)是JS中最准确的类型判断方法
	if(Object.prototype.toString.call(fn)!=="[object Function]"){
		return "Error in params"
	}
	//创建一个空对象，并且把这个空对象的__proto__指向构造函数的prototype
	const obj=Object.create(fn.prototype)
	//将构造函数中的this强行指向obj，ret接受构造函数的返回值（如果有的话）
	let ret=fn.call(obj,...args)
	//如果构造函数有返回值，就返回ret，否则返回obj
	return ret instanceof Object?ret:obj
}
```

---
*2.21*

6. 深、浅拷贝
```javascript
function shallow(obj){
	const newObj={}
	for(const key in obj){
		newObj[key]=obj[key]
	}
	return newObj
}
//支持处理循环引用
function deepCopy(obj,map=new WeakMap()){
	if(obj===null||typeof obj!=='object'){
		return obj
	}
	if(obj instanceof Date)return new Date(obj)
	//source用于获取正则的核心匹配规则，flags用于获取正则的匹配行为（全局、忽略大小写等）
	if(obj instanceof RegExp)return new RegExp(obj.source,obj.flags)
	
	//已经处理过的对象（解决循环引用）
	if(map.has(obj)){
		return map.get(obj)
	}
	
	//处理数组和普通对象
	const clone=Array.isArray(obj)?[]:{}
	//先放入map，防止循环引用
	map.set(obj,clone)
	//使用Reflect.ownKeys 能拿到 Symbol 属性
	const keys=Reflect.ownKeys(obj)
	for(const key of keys){
		clone[key]=deepCopy(obj[key],map)
	}
	return clone
}
```
- Reflect.ownKeys() 返回对象**自身所有属性名**的数组，包括：
    - 可枚举的字符串 key
    - 不可枚举的字符串 key
    - **Symbol key**
- 比 Object.keys() 更全面（Object.keys 只返回可枚举字符串 key）。
- 比 for...in 更好（for...in 会遍历原型链）。

**优点**：
- 处理了循环引用（WeakMap + 先 set 后递归）
- 支持 Symbol 属性（Reflect.ownKeys）
- 正确处理 Date 和 RegExp
- 代码结构清晰，分层明显
- 递归出口写得安全（null + 基本类型）

**可以主动说的不足 / 优化点**：
1. 原型链没有保留（自定义 class 实例会丢失原型） → 可以改成 Object.create(Object.getPrototypeOf(obj))
2. 没有处理 Map / Set / WeakMap / Error 等特殊类型
3. 函数属性只是浅拷贝（函数本身不会深拷贝内部闭包）
4. 不可枚举属性被拷贝了，但描述符（writable/configurable）丢失了

**极简版（JSON 方法）的缺点**：
- undefined / Symbol / 函数 → 直接丢失
- Date → 变成字符串
- RegExp → 变成 {}
- 循环引用 → 直接报错


7. flat
```javascript
//数组扁平化(可指定深度)
function flatten(arr,depth=Infinity){
	const result=[]
	function helper(item,curDepth){
		if(Array.isArray(item)&&curDepth<depth){
			for(let i=0;i<item.length;i++){
				helper(item[i],curDepth+1)
			}
		}else{
			result.push(item)
		}
	}
	helper(arr,0)
	return result
}
```
8. Ajax
```javascript
function ajax(url,options={}){
	//1.解构参数
	const{
		method='GET',
		data=null,
		headers={},
		timeout=10000
	}=options;
	return new Promise((resolve,reject)=>{
		//2.创建一个HTTP请求实例(XHR对象)
		const xhr=new XMLHttpRequest()
		//3.初始化HTTP请求(true表示异步请求)
		xhr.open(method.toUpperCase(),url,true)
		//4.设置请求头
		Object.entries(headers).forEach(([k,v])=>{
			xhr.setRequestHeader(k,v)
		})
		xhr.responseType='json'
		//5.设置监听事件
		xhr.onload=()=>{
			if(xhr.status>=200&&xhr.status<300){
				resolve(xhr.response)
			}else{
				reject({
					status:xhr.status,
					statusText:xhr.statusText,
					response:xhr.response
				})
			}
		}
	})
}
```
8. call
```javascript

```
8. 函数柯里化
```javascript

```
8. 将数字每千分位用逗号隔开
```javascript

```
8. 洗牌算法
```javascript

```