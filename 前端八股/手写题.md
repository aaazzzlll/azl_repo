1. instanceof
```javascript
function myInstanceof(left,right){
	//判断右侧是否为合法的构造函数，不是的话就抛出错误
	if(typeof right!=='function'||!right.prototype){
	throw new TypeError('Right-hand side of instanceof must be a constructor')
	}
	//过滤原始类型和null
	if(typeof left!=='object'||left===null)return false
	
	let proto=Object.getPrototypeOf(left)
	while(true){
		if(proto===null)return false
		if(proto===right.prototype)return true
		proto=Object.getPrototypeOf(proto)
	}
}
```

2. 数组转树
```javascript
let list = [ 
	{ id: 1, name: '部门1', pid: 0 }, 
	{ id: 2, name: '部门2', pid: 1 }, 
	{ id: 3, name: '部门3', pid: 1 }, 
	{ id: 4, name: '部门4', pid: 3 }, 
	{ id: 5, name: '部门5', pid: 4 }, 
];

function arrayToTree(list){
	const result=[]
	const map={}  //存放id到节点的映射
	
	for(const item of list){
		map[item.id]={...item,children:[]}
	}
	
	for(const item of list){
		const id=item.id
		const pid=item.pid
		const node=map[item.id]
		if(pid===0){
			//如果pid是0，说明是根节点
			result.push(node)
		}else{
			// 边界处理：如果数据有问题，parent 找不到，可以暂时忽略或作为根节点处理
			if(!node.pid)continue
			map[pid].children.push(node)
		}
	}
	
	return result
}
```

3. 防抖
使用场景：搜索框输入
```javascript
function debounce(fn,delay){
	let timer=null
	return function(...args){
		if(timer)clearTimeOut(timer)
		timer=setTimeOut(()=>{
			fn.apply(this,args)
		},delay)
	}
}
```
4. 节流
使用场景：滚动条事件
```javascript
//时间戳版：用户点第一下马上响应，后面点的都屏蔽掉，所以可能丢掉最后一次操作
function throttle(fn,delay){
	
}

//定时器版：用户点的一瞬间没反应，
```

“为什么要用 `fn.apply(this, args)`？”

> "因为防抖和节流函数最终是作为事件处理函数执行的。
> 1. **关于 `this`**：如果不绑定 `this`，定时器（普通函数）内部的 `this` 可能会指向 `window`（严格模式下是 `undefined`）。我们需要让 `fn` 里的 `this` 正确指向触发事件的 DOM 元素。
>     
> 2. **关于 `args`**：事件触发时会传递 `Event` 对象，我们需要用 `...args` 接收这些参数，并通过 `apply` 透传给原函数，否则原函数就拿不到 `event` 对象了。"
>

4. new
5. 深、浅拷贝
6. flat
7. Ajax
8. call
9. 函数柯里化
10. function throttle(fn, delay) {
  let timer = null; // 标志位 / 锁

  return function(...args) {
    const context = this;

    // 如果定时器还在，说明上一次还没执行完（或者还在CD中），直接忽略
    if (timer) {
      return;
    }

    // 开启定时器
    timer = setTimeout(() => {
      // 时间到了，执行逻辑
      fn.apply(context, args);
      
      // 执行完后，把 timer 设为 null，表示“CD结束”，可以接受下一次请求了
      timer = null; 
    }, delay);
  };
}