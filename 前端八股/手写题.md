1. instanceof
```javascript
function myInstanceof(left,right){
	//判断右侧是否为合法的构造函数，不是的话就抛出错误
	if(typeof right!=='function'||!right.prototype){
	throw new TypeError('Right-hand side of instanceof must be a constructor')
	}
	//过滤原始类型和null
	if(typeof left!=='object'||left===null)return false
	
	let proto=Object.getPrototypeOf(left)
	while(true){
		if(proto===null)return false
		if(proto===right.prototype)return true
		proto=Object.getPrototypeOf(proto)
	}
}
```

2. 数组转树
```javascript
let list = [ 
	{ id: 1, name: '部门1', pid: 0 }, 
	{ id: 2, name: '部门2', pid: 1 }, 
	{ id: 3, name: '部门3', pid: 1 }, 
	{ id: 4, name: '部门4', pid: 3 }, 
	{ id: 5, name: '部门5', pid: 4 }, 
];

function arrayToTree(list){
	const result=[]
	const map={}  //存放id到节点的映射
	
	for(const item of list){
		map[item.id]={...item,children:[]}
	}
	
	for(const item of list){
		const id=item.id
		const pid=item.pid
		const node=map[item.id]
		if(pid===0){
			//如果pid是0，说明是根节点
			result.push(node)
		}else{
			// 边界处理：如果数据有问题，parent 找不到，可以暂时忽略或作为根节点处理
			if(!node.pid)continue
			map[pid].children.push(node)
		}
	}
	
	return result
}
```

3. 防抖
使用场景：搜索框输入
```javascript
function debounce(fn,delay){
	let timer=null
	return function(...args){
		if(timer)clearTimeOut(timer)
		timer=setTimeOut(()=>{
			fn.apply(this,args)
		},delay)
	}
}
```

4. 节流
使用场景：滚动条事件
```javascript
//时间戳版：在第一次触发事件时立即执行，以后每过 delay 秒之后才执行一次，并且最后一次触发事件不会被执行
function throttle(fn,delay){
	let last=0
	return function(...args){
		const now=new Date().getTime()
		if(now-last>=delay){
			fn.apply(this,args)
			last=now
		}
	}
}

//定时器版：用户点的一瞬间没反应，此时设置了一个定时器，时间到就执行函数
function throttle(fn,delay){
	let timer=null
	
	return function(...args){
		if(timer)return
		timer=setTimeOut(()=>{
			fn.apply(this,args)
			timer=null
		},delay)
	}
}
```

“为什么要用 `fn.apply(this, args)`？”

> "因为防抖和节流函数最终是作为事件处理函数执行的。
> 1. **关于 `this`**：如果不绑定 `this`，定时器（普通函数）内部的 `this` 可能会指向 `window`（严格模式下是 `undefined`）。我们需要让 `fn` 里的 `this` 正确指向触发事件的 DOM 元素。
>     
> 2. **关于 `args`**：事件触发时会传递 `Event` 对象，我们需要用 `...args` 接收这些参数，并通过 `apply` 透传给原函数，否则原函数就拿不到 `event` 对象了。"
>

5. new
```javascript
function myNew(fn,...args){
	if(Object.prototype.toString.call(fn))
}
```
6. 深、浅拷贝
```javascript
function 
```
7. flat
```javascript

```
8. Ajax
```javascript

```
8. call
```javascript

```
8. 函数柯里化
```javascript

```
8. 将数字每千分位用逗号隔开
```javascript

```
8. 洗牌算法
```javascript

```