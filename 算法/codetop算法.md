
==ACM模式输入输出模版==
```javascript
const fs = require('fs');

// --- 第一步：这是你熟悉的 LeetCode 写法 ---
// 你就当这里是力扣的编辑器，完全不用管输入怎么来的
function twoSum(a, b) {
    return a + b;
}

// --- 第二步：这是你需要背下来的“壳” ---
function main() {
    // 1. 读数据（死记硬背）
    const input = fs.readFileSync(0, 'utf-8');
    const tokens = input.trim().split(/\s+/);
    let cur = 0;
    const nextInt = () => parseInt(tokens[cur++]);

    // 2. 准备参数（把数据喂给你的函数）
    // 假设题目说是一组测试数据，两个数
    const a = nextInt();
    const b = nextInt();

    // 3. 调用你的 LeetCode 函数并打印
    const ans = twoSum(a, b); 
    console.log(ans);
}

main();
```

1. 无重复字符的最长子串
采用**滑动窗口（双指针）+ 哈希集合**，左指针遍历字符串作为窗口左边界，右指针尽可能扩展窗口右边界（确保窗口内无重复字符），同时更新最长无重复子串长度，最终得到结果。
注意：右边界初始值为-1
`时间复杂度：O(N) `

2. 比较版本号
采用**双指针**逐段解析版本号，以小数点为分隔符，分别提取两个版本号的对应段并转换为整数进行比较，若某一段数值不等则直接返回比较结果，全部段相等则返回0
`时间复杂度：O(n+m)    空间复杂度：O(1)`

3. 合并两个有序数组
采用逆向双指针（从后往前填充），避免覆盖nums1有效元素，对比两个数组末尾的有效元素，将较大值放入nums1的末尾空闲位置，最终完成两个有序数组的合并
`时间复杂度：O(m+n)     空间复杂度：O(1)`

4. 有效的括号
采用**栈+哈希表**校验括号合法性，哈希表存储右括号与对应左括号的映射，遍历字符串时左括号入栈，遇到右括号则校验栈顶是否为匹配的左括号（不匹配直接返回false，匹配则出栈），最终通过栈是否为空判断所有括号是否完全匹配
注意：需要提前拦截奇数长度的字符串
`时间复杂度：O(n)       空间复杂度：O(n+6)`

5. 字符串相加
采用**逆向双指针模拟竖式加法**，从两个数字字符串的末尾开始逐位相加，维护进位值处理超 10 进 1 的情况，逐位记录相加结果，最后反转结果并拼接为字符串得到最终和。
注意：使用charCodeAt()可以降低执行用时
`时间复杂度：O(max(len1,len2))    空间复杂度：O(1)`

6. 两数之和
采用**哈希表（Map / 对象）+ 单次遍历**，遍历数组时记录已访问元素的「数值 - 索引」映射，对每个元素计算其与目标值的补数，若补数已在哈希表中则直接返回补数索引和当前索引，否则将当前元素存入哈希表
`时间复杂度：O(n)       空间复杂度：O(n)`

7. 全排列
采用**回溯 + 原地交换**的方式，通过`first`参数固定排列的当前位置，从该位置开始遍历并交换元素生成不同排列分支，递归处理下一个位置，递归返回后撤销交换恢复数组状态，直到所有位置都确定（`first`等于数组长度），将当前排列深拷贝存入结果集，最终得到数组的所有全排列。
`时间复杂度：O(n*n!)       空间复杂度：O(n)`

8. 反转链表
迭代：通过**双指针 + 循环**，用 prev 记录当前节点的前驱节点，curr 遍历链表，每次先保存 curr 的后继节点，再将 curr 的 next 指向 prev，随后更新 prev 和 curr 指针，逐步反转链表指向，最终 prev 成为反转后的头节点。
`时间复杂度：O(n)       空间复杂度：O(1)`

递归：采用**拆解子问题 + 回溯调整**，先递归拆解到链表最后一个节点（作为新头节点），再从后往前让当前节点的下一个节点指向自己，同时将当前节点的 next 置空，最终返回新头节点完成链表反转。
`时间复杂度：O(n)       空间复杂度：O(n)`


9. 二叉树的层序遍历
使用res数组保存结果，queue搭配while循环，每进行一次循环都是对当前层的节点进行遍历。
在while循环内部使用for循环，每取出一个节点就往队列中添加他的左右子节点（存在则添加，不存在不添加），同时将该节点的值push到`res[res.length-1]`中
`时间复杂度：O(n)       空间复杂度：O(n)`

10. 最大子数组和
遍历数组时，用prev维护以当前元素结尾的子数组的最大和（决策是否加入前一个子数组），同时用max记录遍历过程中所有prev的最大值，最终max为最大子数组和
`时间复杂度：O(n)       空间复杂度：O(1)`

11. 三数之和
先对数组排序，for循环遍历固定每个数作为三元组第一个数（跳过重复数），while循环再在其右侧区间用双指针（左指针右移找更大数、右指针左移找更小数）找和为该数相反数的两个数，找到后跳过重复数继续查找，最终收集所有不重复的三元组
$$
时间复杂度：O(n^2)           空间复杂度：O(logN)
$$

12. 买卖股票的最佳时机
遍历价格数组时，用minPrice动态记录遍历到当前位置的最低价格，同时用maxProfit计算当前价格与minPrice的差值，始终保留最大的差值作为最大利润，最终得到全局的最大收益
注意：minPrice初始值为Infinity，maxProfit初始值为0
`时间复杂度：O(n)       空间复杂度：O(1)`

13. 环形链表
采用快慢指针遍历链表，慢指针每次走一步、快指针每次走两步，若链表存在环则快慢指针最终会相遇，若快指针先走到链表末尾（null）则说明无环
`时间复杂度：O(n)       空间复杂度：O(1)`

14. 路径总和
- 采用**层序遍历（广度优先）+ 双队列**，用节点队列遍历二叉树节点，同步用路径和队列记录从根到当前节点的路径和，遍历到叶子节点时校验路径和是否等于目标值，匹配则返回 true，遍历完所有节点未匹配则返回 false。
`时间复杂度：O(n)       空间复杂度：O(n)`

- 采用**递归（深度优先）+ 问题拆解**，将目标和逐步减去当前节点值后，递归校验左 / 右子树是否存在从当前节点到叶子的路径和等于剩余值，叶子节点直接判断自身值是否匹配剩余目标和，空节点则返回 false。
`时间复杂度：O(n)       空间复杂度：O(h) h为树的高度`

15. LRU缓存机制
使用双向链表和哈希表，哈希表存储（key，node）键值对，node包含key，value，prev，next。该双向链表还需要设置伪头部和伪尾部，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。
在LRUCache的构造函数中，定义了createLinkedNode、addToHead、moveToHead
、removeNode、removeTail五个实例方法；cache是保存键值对的哈希表，capacity是容量，size是缓存目前被占用的大小，head和tail是链表的伪头伪尾。

对于 get 操作，首先判断 key 是否存在：如果 key 不存在，则返回 −1；如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。

对于 put 操作，首先判断 key 是否存在：
如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；
如果 key 存在，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。

`时间复杂度：对于put和get都是O(1)      空间复杂度：O(capacity)`

16. 合并两个有序链表
采用**虚拟头节点的迭代算法**，用 prev 指针遍历两个有序链表，每次将值更小的节点接在 prev 后并移动对应链表指针，遍历完后将未遍历完的链表剩余部分接在末尾，最终返回虚拟头节点的下一个节点即为合并后的有序链表。
`时间复杂度：O(n+m)       空间复杂度：O(1)`

17. 爬楼梯
利用**动态规划 + 迭代优化空间**，基于 “第 n 阶台阶的走法数 = 第 n-1 阶 + 第 n-2 阶走法数” 的递推关系，用两个变量滚动记录前两阶的走法数，迭代计算到第 n 阶，避免递归的重复计算和额外空间消耗。
`时间复杂度：O(n)       空间复杂度：O(1)`

18. 最长回文子串
以字符串每个字符为奇数长度回文的中心、每两个相邻字符为偶数长度回文的中心，通过中心扩展函数向左右延伸找最长回文子串，记录最长回文的起止下标，最终截取对应子串。
```javascript
//扩展函数
function expand(s,left,right)
```
$$
时间复杂度：O(n^2)           空间复杂度：O(1)
$$

19. 数组中的第K个最大元素
采用**快速选择算法**，随机选取基准值将数组划分为大于、等于、小于基准值的三部分，根据 k 与大于基准值数组长度的关系递归缩小查找范围，若 k 落在等于区间则直接返回基准值，高效找到第 k 大元素。
```javascript
//快速选择函数
const quickSelect(numList,k)
```
$$
时间复杂度：O(n)           空间复杂度：O(logN)
$$

20. 手撕快速排序
该快速排序算法的核心思路可拆解为「先优化判断、再分区、最后递归」三步：

-  **递归排序函数（quickSort）**：接收待排序子数组的左右边界`left/right`，首先遍历子数组判断是否已有序 —— 若所有元素升序则直接返回（避免无意义递归）；若无序则调用分区函数找到基准值的最终下标，再递归对基准值左侧（≤基准）、右侧（≥基准）的子数组重复执行排序逻辑；
- **分区函数（partition）**：是核心步骤，先在`[left, right]`范围内随机选一个基准值并交换到子数组左端（避免有序数组导致算法退化），再用相向双指针（左指针`i`从`left+1`右移找≥基准的元素，右指针`j`从`right`左移找≤基准的元素），交换指针指向的元素以维持「左≤基准、右≥基准」的规则，直到指针相遇 / 交叉；最后将左端的基准值交换到指针`j`的位置（基准最终归位），返回基准下标；
-  **整体流程**：入口函数调用`quickSort`处理整个数组，通过「有序判断优化 + 随机基准分区 + 递归排序子数组」完成整体升序排序，且所有操作均在原数组上进行（原地排序）。

### 关键记忆点（写代码时的核心步骤）

- 写`quickSort`：先判有序→无序则分区→递归左右；
- 写`partition`：随机选基准换左端→双指针相向遍历交换→基准归位`j`并返回；
- 双指针规则：`i`找≥基准、`j`找≤基准，交换后指针各走一步，`i≥j`时停止；
- 基准归位：必须和`j`交换（而非`i`），避免下标越界或分区失效。

搭好`sortArray`→`quickSort`→`partition`的函数结构

$$
时间复杂度：O(NlogN)           空间复杂度：O(logN)
$$

21. 螺旋矩阵
该算法通过维护上下左右四个边界，按「上→右→下→左」的顺序循环遍历矩阵并收集元素，直至收集完所有元素；**核心注意事项**：需在每轮方向遍历中检查是否已收集完所有元素并提前终止，否则非正方形矩阵 / 最后一圈遍历会出现重复添加元素或下标越界问题。还需要考虑数组为空的边界条件。
$$
时间复杂度：O(m*n)      空间复杂度：O(1)(不计输出数组)
$$

22. 岛屿数量
双层循环遍历网格发现陆地则计数 + 1，通过 DFS 递归向上下左右深度遍历，将该岛屿所有相连陆地标记为水域，避免重复计数，最终返回总计数。
在dfs函数中需要判断是否越界以及是否是陆地，如果越界或者是水域，就直接返回
$$
时间复杂度：O(m*n)      空间复杂度：O(m*n)
$$

23. 合并区间
该算法先处理空区间数组的边界场景，再将所有区间按左端点升序排序，随后遍历排序后的区间，若结果数组为空或当前区间与结果数组最后一个区间无重叠（当前区间左端点大于最后一个区间右端点）则直接加入，否则合并（更新最后一个区间的右端点为两者最大值），最终得到无重叠的合并区间数组。
$$
时间复杂度：主要时间开销是排序的 O(nlogn)。

空间复杂度：O(logn) 为排序所需的空间复杂度。
$$

24. 最长上升子序列
该算法通过动态规划求解最长递增子序列长度：先处理空数组边界，构建 dp 数组（`dp [i]` 表示以 `nums [i] `结尾的最长递增子序列长度），初始化` dp [0]=1`，外层遍历每个位置 i 并初始化 `dp [i]=1`，内层遍历 i 之前的所有位置 j，若` nums [i]>nums [j]` 则更新 `dp [i] `为 `dp [j]+1` 的最大值，同时维护全局最长长度 max，最终返回 max 即为答案。

$$
时间复杂度：O(n^2)           空间复杂度：O(n)
$$

---
*2.21*

25. 二分查找
初始化左右指针指向数组首尾，在`left<=right`的循环中计算中间下标`mid`，比较目标值与中间元素，若相等则返回`mid`；若目标值更大则将左指针移至`mid+1`，更小则将右指针移至`mid-1`，循环结束未找到则返回 - 1，实现有序数组中高效查找目标值下标。
$$
时间复杂度：O(logn)           空间复杂度：O(1)
$$

26. 求根到叶子节点数字之和
该递归解法通过深度优先搜索（DFS）遍历二叉树，递归函数接收当前节点和路径累积数值，将累积值更新为`prevSum*10 + 当前节点值`，若为叶子节点则返回该累积值，否则递归计算左右子树的路径和并相加，最终返回所有根到叶子节点的路径数值之和。

该非递归解法采用广度优先搜索（BFS），借助两个队列分别存储遍历的节点和对应路径累积数值，初始化时将根节点和根节点值入队，遍历队列时取出节点和数值，若为叶子节点则累加数值到总和，否则将左右子节点及更新后的路径数值（`当前数值*10 + 子节点值`）入队，最终得到所有根到叶子节点的路径数值之和。
$$
两种解法的时间空间复杂度一样：
时间复杂度：O(n)           空间复杂度：O(n)
$$

27. 复原IP地址
该算法采用深度优先搜索（DFS）+ 回溯的思路复原合法 IP 地址：先定义 4 段 IP 的固定长度常量，用数组存储每段数值，递归函数接收「当前拆分段数 segId、字符串起始拆分位置 segStart」，递归中先判断终止条件（拆完 4 段且遍历完字符串则收集结果，未拆完但字符串遍历完则回溯）；再处理前导零特殊情况（当前位为 0 则该段只能是 0，直接递归下一段）；常规情况枚举 1-3 位数字计算段值，验证≤255 则记录该段并递归下一段，最终返回所有合法 IP 组合。

### 核心记忆点（写代码的关键步骤）

1. 初始化：定义`SEG_COUNT=4`、存储段值的`segments`数组、结果数组`ans`；
2. 递归函数（dfs）：
    
    - 终止条件：`segId===4`时，若`segStart===s.length`则拼接结果；`segStart===s.length`直接返回；
    - 前导零处理：当前位为 0 则该段设为 0，递归下一段并返回；
    - 枚举验证：循环计算 1-3 位段值，≤255 则记录段值并递归下一段，超范围则 break；
3. 初始调用`dfs(s,0,0)`，返回结果数组。
$$
时间复杂度：O(3SEG_COUNT×∣s∣)。


$$
---

27. 零钱兑换
28. 括号生成
29. 链表中倒数第k个节点
30. 二叉树的最大深度
31. 二叉树的中序遍历
32. 斐波那契数列
33. 岛屿的最大面积
34. 接雨水
35. 最长公共子序列
36. 最长公共前缀
37. 翻转二叉树
38. 千位分隔数
39. 不同路径

