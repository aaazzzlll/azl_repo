
==ACM模式输入输出模版==
```javascript
const fs = require('fs');

// --- 第一步：这是你熟悉的 LeetCode 写法 ---
// 你就当这里是力扣的编辑器，完全不用管输入怎么来的
function twoSum(a, b) {
    return a + b;
}

// --- 第二步：这是你需要背下来的“壳” ---
function main() {
    // 1. 读数据（死记硬背）
    const input = fs.readFileSync(0, 'utf-8');
    const tokens = input.trim().split(/\s+/);
    let cur = 0;
    const nextInt = () => parseInt(tokens[cur++]);

    // 2. 准备参数（把数据喂给你的函数）
    // 假设题目说是一组测试数据，两个数
    const a = nextInt();
    const b = nextInt();

    // 3. 调用你的 LeetCode 函数并打印
    const ans = twoSum(a, b); 
    console.log(ans);
}

main();
```

1. 无重复字符的最长子串
采用**滑动窗口（双指针）+ 哈希集合**，左指针遍历字符串作为窗口左边界，右指针尽可能扩展窗口右边界（确保窗口内无重复字符），同时更新最长无重复子串长度，最终得到结果。
注意：右边界初始值为-1
`时间复杂度：O(N) `

2. 比较版本号
采用**双指针**逐段解析版本号，以小数点为分隔符，分别提取两个版本号的对应段并转换为整数进行比较，若某一段数值不等则直接返回比较结果，全部段相等则返回0
`时间复杂度：O(n+m)    空间复杂度：O(1)`

3. 合并两个有序数组
采用逆向双指针（从后往前填充），避免覆盖nums1有效元素，对比两个数组末尾的有效元素，将较大值放入nums1的末尾空闲位置，最终完成两个有序数组的合并
`时间复杂度：O(m+n)     空间复杂度：O(1)`

4. 有效的括号
采用**栈+哈希表**校验括号合法性，哈希表存储右括号与对应左括号的映射，遍历字符串时左括号入栈，遇到右括号则校验栈顶是否为匹配的左括号（不匹配直接返回false，匹配则出栈），最终通过栈是否为空判断所有括号是否完全匹配
注意：需要提前拦截奇数长度的字符串
`时间复杂度：O(n)       空间复杂度：O(n+6)`

5. 字符串相加
采用**逆向双指针模拟竖式加法**，从两个数字字符串的末尾开始逐位相加，维护进位值处理超 10 进 1 的情况，逐位记录相加结果，最后反转结果并拼接为字符串得到最终和。
注意：使用charCodeAt()可以降低执行用时
`时间复杂度：O(max(len1,len2))    空间复杂度：O(1)`

6. 两数之和
采用**哈希表（Map / 对象）+ 单次遍历**，遍历数组时记录已访问元素的「数值 - 索引」映射，对每个元素计算其与目标值的补数，若补数已在哈希表中则直接返回补数索引和当前索引，否则将当前元素存入哈希表
`时间复杂度：O(n)       空间复杂度：O(n)`

7. 全排列
采用**回溯 + 原地交换**的方式，通过`first`参数固定排列的当前位置，从该位置开始遍历并交换元素生成不同排列分支，递归处理下一个位置，递归返回后撤销交换恢复数组状态，直到所有位置都确定（`first`等于数组长度），将当前排列深拷贝存入结果集，最终得到数组的所有全排列。
`时间复杂度：O(n*n!)       空间复杂度：O(n)`

8. 反转链表
迭代：通过**双指针 + 循环**，用 prev 记录当前节点的前驱节点，curr 遍历链表，每次先保存 curr 的后继节点，再将 curr 的 next 指向 prev，随后更新 prev 和 curr 指针，逐步反转链表指向，最终 prev 成为反转后的头节点。
`时间复杂度：O(n)       空间复杂度：O(1)`

递归：采用**拆解子问题 + 回溯调整**，先递归拆解到链表最后一个节点（作为新头节点），再从后往前让当前节点的下一个节点指向自己，同时将当前节点的 next 置空，最终返回新头节点完成链表反转。
`时间复杂度：O(n)       空间复杂度：O(n)`


9. 二叉树的层序遍历
使用res数组保存结果，queue搭配while循环，每进行一次循环都是对当前层的节点进行遍历。
在while循环内部使用for循环，每取出一个节点就往队列中添加他的左右子节点（存在则添加，不存在不添加），同时将该节点的值push到`res[res.length-1]`中
`时间复杂度：O(n)       空间复杂度：O(n)`

10. 最大子数组和
遍历数组时，用prev维护以当前元素结尾的子数组的最大和（决策是否加入前一个子数组），同时用max记录遍历过程中所有prev的最大值，最终max为最大子数组和
`时间复杂度：O(n)       空间复杂度：O(1)`

11. 三数之和
先对数组排序，遍历固定每个数作为三元组第一个数（跳过重复数），再在其右侧区间用双指针（左指针右移找更大数、右指针左移找更小数）找和为该数相反数的两个数，找到后跳过重复数继续查找，最终收集所有不重复的三元组
$$
时间复杂度：O(n^2)           空间复杂度：O(logN)
$$

12. 买卖股票的最佳时机


13. 环形链表


14. LRU缓存机制


15. 路径总和


16. 合并两个有序链表


17. 爬楼梯


18. 最长回文子串


19. 数组中的第K个最大元素


20. 手撕快速排序

