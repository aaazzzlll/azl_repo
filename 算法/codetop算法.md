
==ACM模式输入输出模版==
```javascript
const fs = require('fs');

// --- 第一步：这是你熟悉的 LeetCode 写法 ---
// 你就当这里是力扣的编辑器，完全不用管输入怎么来的
function twoSum(a, b) {
    return a + b;
}

// --- 第二步：这是你需要背下来的“壳” ---
function main() {
    // 1. 读数据（死记硬背）
    const input = fs.readFileSync(0, 'utf-8');
    const tokens = input.trim().split(/\s+/);
    let cur = 0;
    const nextInt = () => parseInt(tokens[cur++]);

    // 2. 准备参数（把数据喂给你的函数）
    // 假设题目说是一组测试数据，两个数
    const a = nextInt();
    const b = nextInt();

    // 3. 调用你的 LeetCode 函数并打印
    const ans = twoSum(a, b); 
    console.log(ans);
}

main();
```

1. 无重复字符的最长子串
采用**滑动窗口（双指针）+ 哈希集合**，左指针遍历字符串作为窗口左边界，右指针尽可能扩展窗口右边界（确保窗口内无重复字符），同时更新最长无重复子串长度，最终得到结果。
注意：右边界初始值为-1
`时间复杂度：O(N) `

2. 比较版本号
采用**双指针**逐段解析版本号，以小数点为分隔符，分别提取两个版本号的对应段并转换为整数进行比较，若某一段数值不等则直接返回比较结果，全部段相等则返回0
`时间复杂度：O(n+m)    空间复杂度：O(1)`

3. 合并两个有序数组
采用逆向双指针（从后往前填充），避免覆盖nums1有效元素，对比两个数组末尾的有效元素，将较大值放入nums1的末尾空闲位置，最终完成两个有序数组的合并
`时间复杂度：O(m+n)     空间复杂度：O(1)`

4. 有效的括号
采用**栈+哈希表**校验括号合法性，哈希表存储右括号与对应左括号的映射，遍历字符串时左括号入栈，遇到右括号则校验栈顶是否为匹配的左括号（不匹配直接返回false，匹配则出栈），最终通过栈是否为空判断所有括号是否完全匹配
注意：需要提前拦截奇数长度的字符串
`时间复杂度：O(n)       空间复杂度：O(n+6)`

5. 字符串相加
采用**逆向双指针模拟竖式加法**，从两个数字字符串的末尾开始逐位相加，维护进位值处理超 10 进 1 的情况，逐位记录相加结果，最后反转结果并拼接为字符串得到最终和。
注意：使用charCodeAt()可以降低执行用时
`时间复杂度：O(max(len1,len2))    空间复杂度：O(1)`

6. 两数之和
采用**哈希表（Map / 对象）+ 单次遍历**，遍历数组时记录已访问元素的「数值 - 索引」映射，对每个元素计算其与目标值的补数，若补数已在哈希表中则直接返回补数索引和当前索引，否则将当前元素存入哈希表
`时间复杂度：O(n)       空间复杂度：O(n)`

7. 全排列
采用**回溯 + 原地交换**的方式，通过`first`参数固定排列的当前位置，从该位置开始遍历并交换元素生成不同排列分支，递归处理下一个位置，递归返回后撤销交换恢复数组状态，直到所有位置都确定（`first`等于数组长度），将当前排列深拷贝存入结果集，最终得到数组的所有全排列。
`时间复杂度：O(n*n!)       空间复杂度：O(n)`

8. 反转链表
迭代：通过**双指针 + 循环**，用 prev 记录当前节点的前驱节点，curr 遍历链表，每次先保存 curr 的后继节点，再将 curr 的 next 指向 prev，随后更新 prev 和 curr 指针，逐步反转链表指向，最终 prev 成为反转后的头节点。
`时间复杂度：O(n)       空间复杂度：O(1)`

递归：采用**拆解子问题 + 回溯调整**，先递归拆解到链表最后一个节点（作为新头节点），再从后往前让当前节点的下一个节点指向自己，同时将当前节点的 next 置空，最终返回新头节点完成链表反转。
`时间复杂度：O(n)       空间复杂度：O(n)`


9. 二叉树的层序遍历
使用res数组保存结果，queue搭配while循环，每进行一次循环都是对当前层的节点进行遍历。
在while循环内部使用for循环，每取出一个节点就往队列中添加他的左右子节点（存在则添加，不存在不添加），同时将该节点的值push到`res[res.length-1]`中
`时间复杂度：O(n)       空间复杂度：O(n)`

10. 最大子数组和
遍历数组时，用prev维护以当前元素结尾的子数组的最大和（决策是否加入前一个子数组），同时用max记录遍历过程中所有prev的最大值，最终max为最大子数组和
`时间复杂度：O(n)       空间复杂度：O(1)`

11. 三数之和
先对数组排序，for循环遍历固定每个数作为三元组第一个数（跳过重复数），while循环再在其右侧区间用双指针（左指针右移找更大数、右指针左移找更小数）找和为该数相反数的两个数，找到后跳过重复数继续查找，最终收集所有不重复的三元组
$$
时间复杂度：O(n^2)           空间复杂度：O(logN)
$$

12. 买卖股票的最佳时机
遍历价格数组时，用minPrice动态记录遍历到当前位置的最低价格，同时用maxProfit计算当前价格与minPrice的差值，始终保留最大的差值作为最大利润，最终得到全局的最大收益
注意：minPrice初始值为Infinity，maxProfit初始值为0
`时间复杂度：O(n)       空间复杂度：O(1)`

13. 环形链表
采用快慢指针遍历链表，慢指针每次走一步、快指针每次走两步，若链表存在环则快慢指针最终会相遇，若快指针先走到链表末尾（null）则说明无环
`时间复杂度：O(n)       空间复杂度：O(1)`

14. 路径总和
- 采用**层序遍历（广度优先）+ 双队列**，用节点队列遍历二叉树节点，同步用路径和队列记录从根到当前节点的路径和，遍历到叶子节点时校验路径和是否等于目标值，匹配则返回 true，遍历完所有节点未匹配则返回 false。
`时间复杂度：O(n)       空间复杂度：O(n)`

- 采用**递归（深度优先）+ 问题拆解**，将目标和逐步减去当前节点值后，递归校验左 / 右子树是否存在从当前节点到叶子的路径和等于剩余值，叶子节点直接判断自身值是否匹配剩余目标和，空节点则返回 false。
`时间复杂度：O(n)       空间复杂度：O(h) h为树的高度`

15. LRU缓存机制
使用双向链表和哈希表，哈希表存储（key，node）键值对，node包含key，value，prev，next。该双向链表还需要设置伪头部和伪尾部，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。
在LRUCache的构造函数中，定义了createLinkedNode、addToHead、moveToHead
、removeNode、removeTail五个实例方法；cache是保存键值对的哈希表，capacity是容量，size是缓存目前被占用的大小

对于 get 操作，首先判断 key 是否存在：如果 key 不存在，则返回 −1；如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。

对于 put 操作，首先判断 key 是否存在：
如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；
如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。




16. 合并两个有序链表


17. 爬楼梯


18. 最长回文子串


19. 数组中的第K个最大元素


20. 手撕快速排序
21. 螺旋矩阵
22. 岛屿数量
23. 合并区间
24. 最长上升子序列
25. 二分查找
26. 求根到叶子节点数字之和
27. 复原IP地址
28. 零钱兑换
29. 括号生成
30. 链表中倒数第k个节点
31. 二叉树的最大深度
32. 二叉树的中序遍历
33. 斐波那契数列
34. 岛屿的最大面积
35. 接雨水
36. 最长公共子序列
37. 最长公共前缀
38. 翻转二叉树
39. 千位分隔数
40. 不同路径

