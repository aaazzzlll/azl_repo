
==ACM模式输入输出模版==
```javascript
const fs = require('fs');

// --- 第一步：这是你熟悉的 LeetCode 写法 ---
// 你就当这里是力扣的编辑器，完全不用管输入怎么来的
function twoSum(a, b) {
    return a + b;
}

// --- 第二步：这是你需要背下来的“壳” ---
function main() {
    // 1. 读数据（死记硬背）
    const input = fs.readFileSync(0, 'utf-8');
    const tokens = input.trim().split(/\s+/);
    let cur = 0;
    const nextInt = () => parseInt(tokens[cur++]);

    // 2. 准备参数（把数据喂给你的函数）
    // 假设题目说是一组测试数据，两个数
    const a = nextInt();
    const b = nextInt();

    // 3. 调用你的 LeetCode 函数并打印
    const ans = twoSum(a, b); 
    console.log(ans);
}

main();
```

1. 无重复字符的最长子串
采用**滑动窗口（双指针）+ 哈希集合**，左指针遍历字符串作为窗口左边界，右指针尽可能扩展窗口右边界（确保窗口内无重复字符），同时更新最长无重复子串长度，最终得到结果。
注意：右边界初始值为-1
`时间复杂度：O(N) `

2. 比较版本号
采用**双指针**逐段解析版本号，以小数点为分隔符，分别提取两个版本号的对应段并转换为整数进行比较，若某一段数值不等则直接返回比较结果，全部段相等则返回0
`时间复杂度：O(n+m)    空间复杂度：O(1)`

3. 合并两个有序数组
采用逆向双指针（从后往前填充），避免覆盖nums1有效元素，对比两个数组末尾的有效元素，将较大值放入nums1的末尾空闲位置，最终完成两个有序数组的合并
`时间复杂度：O(m+n)     空间复杂度：O(1)`

4. 有效的括号
采用**栈+哈希表**校验括号合法性，哈希表存储右括号与对应左括号的映射，遍历字符串时左括号入栈，遇到右括号则校验栈顶是否为匹配的左括号（不匹配直接返回false，匹配则出栈），最终通过栈是否为空判断所有括号是否完全匹配
注意：需要提前拦截奇数长度的字符串
`时间复杂度：O(n)       空间复杂度：O(n+6)`

5. 字符串相加
采用**逆向双指针模拟竖式加法**，从两个数字字符串的末尾开始逐位相加，维护进位值处理超 10 进 1 的情况，逐位记录相加结果，最后反转结果并拼接为字符串得到最终和。
注意：使用charCodeAt()可以降低时间复杂度
`时间复杂度：O(max(len1,len2))    空间复杂度：O(1)`

6. 两数之和



7. 全排列

8. 反转链表

9. 二叉树的层序遍历

10. 最大子数组和

11. 三数之和

12. 买卖股票的最佳时机
