# 二叉树

1. 二叉树的直径
递归：使用ans全局记录所有路径中节点数的最大值，初始值为1。递归函数返回值是Node子树的深度，题目要求的是边数，最终结果是ans-1

2. 二叉树的层序遍历
使用res数组保存结果，queue搭配while循环，每进行一次循环都是对当前层的节点进行遍历。
在while循环内部使用for循环，每取出一个节点就往队列中添加他的左右子节点（存在则添加，不存在不添加），同时将该节点的值push到res[res.length-1]中

3. 将有序数组转换为二叉搜索树
使用递归思想，总是选择中间位置左边的数字作为根节点，根节点的下标为 mid=(left+right)/2，递归求根节点的左右子节点

4. 验证二叉搜索树
迭代：使用中序遍历思想，判断pop出的当前节点值是否大于前一个节点的值，如果大于inorder=root.val,否则return false
递归：根节点的合法值域是 `(-∞, +∞)`，无边界限制；
       递归左子树收缩右边界，递归右子树收缩左边界；
       每个节点必须严格在 `(lower, upper)` 范围内，且左右子树都合法。

5. 二叉搜索树中第K小的元素
使用层序遍历二叉搜索树，将每一层的最后一个节点值保存到res中

6. 二叉树展开为链表
使用前序遍历递归算法得到保存二叉树前序遍历序列的list，然后将里面的节点left赋值为null，right设为下一个节点

7. 从前序与中序遍历序列构造二叉树
使用哈希表存储中序序列中的[值-索引]映射，降低时间复杂度。定义递归函数myBuildTree(preLeft,preRight,inLeft,inRight),递归终止条件是preLeft>preRight，sizeLeftSubtree连接前序和中序的边界，是拆分左右子树的关键

8. 路径总和III
