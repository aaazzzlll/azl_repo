# 二叉树

1. 二叉树的直径
递归：使用ans全局记录所有路径中节点数的最大值，初始值为1。递归函数返回值是Node子树的深度，题目要求的是边数，最终结果是ans-1

2. 二叉树的层序遍历
使用res数组保存结果，queue搭配while循环，每进行一次循环都是对当前层的节点进行遍历。
在while循环内部使用for循环，每取出一个节点就往队列中添加他的左右子节点（存在则添加，不存在不添加），同时将该节点的值push到res[res.length-1]中

3. 将有序数组转换为二叉搜索树
使用递归思想，总是选择中间位置左边的数字作为根节点，根节点的下标为 mid=(left+right)/2，递归求根节点的左右子节点

4. 验证二叉搜索树
迭代：使用中序遍历思想，判断pop出的当前节点值是否大于前一个节点的值，如果大于inorder=root.val,否则return false
递归：根节点的合法值域是 `(-∞, +∞)`，无边界限制；
       递归左子树收缩右边界，递归右子树收缩左边界；
       每个节点必须严格在 `(lower, upper)` 范围内，且左右子树都合法。

5. 二叉搜索树中第K小的元素
使用层序遍历二叉搜索树，将每一层的最后一个节点值保存到res中

6. 二叉树展开为链表
使用前序遍历递归算法得到保存二叉树前序遍历序列的list，然后将里面的节点left赋值为null，right设为下一个节点

7. 从前序与中序遍历序列构造二叉树
使用哈希表存储中序序列中的[值-索引]映射，降低时间复杂度。定义递归函数myBuildTree(preLeft,preRight,inLeft,inRight),递归终止条件是preLeft>preRight，sizeLeftSubtree连接前序和中序的边界，是拆分左右子树的关键

8. 路径总和III
使用递归算法，pathSum遍历所有节点，把每个节点当做路径的起点。rootSum从当前起点出发，向下遍历所有路径，统计和为targetSum的路径数。最终结果是所有起点的有效路径数之和。

9. 二叉树的最近公共祖先
从根节点往下递归找 p 和 q，自底向上传递 “找没找到” 的信号，哪个节点最先发现 p 和 q 分别在自己的左右两边，或者自己就是其中一个且另一个在自己子树里，这个节点就是最近公共祖先

10. 二叉树中的最大路径和
定义递归函数maxGain，递归计算每个节点的贡献值（舍弃负值）；以每个节点为顶点，计算 “左右贡献 + 节点值” 的路径和，更新全局最大值；贡献值供父节点拼接，顶点路径和用于更新全局最大值；

# 回溯
- 回溯问题核心：「定义结果集 → 回溯函数（终止条件 + 决策分支 + 选→递归→回溯）→ 初始调用」

1. 子集
使用二进制迭代方法，每一个子集可以对应一个长度为 n 的 0/1 序列，两层for循环，外层循环从0到1<<n,内层循环从0到n

2. 电话号码的字母组合
先建立一个字母数字映射表phoneMap，再定义一个backtrack递归函数，递归终止条件是处理完所有数字，拼接完成一个完整组合。这个算法通过回溯法递归遍历数字串的每一位，对每位数字对应的每个字母依次做 “选择 - 递归处理下一位 - 回溯撤销选择” 的操作，当处理完所有数字时，将当前拼接的字母组合存入结果集，最终得到所有合法的字母组合。

3. 组合总和
递归终止：遍历完元素（index等于candidates.length）或找到有效组合（target等于0）； 
决策1：不选当前元素，递归下一个下标；
决策2：若当前元素可选（剩余target≥元素值），选取后递归同一下标（支持重复选）；  

4. 括号生成

5. 单词搜索
6. 分割回文串

# 二分查找
1. 搜索插入位置
2. 搜索二维矩阵
3. 在排序数组中查找元素的第一个和最后一个位置
4. 搜索旋转排序数组
5. 寻找旋转排序数组中的最小值
# 栈
1. 最小栈
2. 字符串解码
3. 每日温度
4. 柱状图中最大的矩形
# 堆
1. 数组中的第K个最大元素
2. 前K个高频元素
3. 数据流的中位数

# 动态规划
1. 最长有效括号
dp[i]表示以i下标结尾的有效子串的长度，所以结尾如果是'('，就不用处理。结尾如果是')',只有两种情况会更新答案：  
1.s[i-1]是'('，那么它们俩凑成一对，返回dp[i - 2] + 2。  
2.s[i-1]是')'，要想成功匹配，需要在i-1结尾的有效子串（长度为dp[i-1]）前面找到一个'(',该位置就是i-dp[i-1]-1。当然还要算上更早之前的有效长度dp[i - dp[i - 1] - 2]  
注意：这里所有的下标索引操作，都需要判断是否合法（>=0），只有合法才能操作，不合法就设为0