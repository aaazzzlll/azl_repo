# 二叉树

1. 二叉树的直径
递归：使用ans全局记录所有路径中节点数的最大值，初始值为1。递归函数返回值是Node子树的深度，题目要求的是边数，最终结果是ans-1

2. 二叉树的层序遍历
使用res数组保存结果，queue搭配while循环，每进行一次循环都是对当前层的节点进行遍历。
在while循环内部使用for循环，每取出一个节点就往队列中添加他的左右子节点（存在则添加，不存在不添加），同时将该节点的值push到res[res.length-1]中

3. 将有序数组转换为二叉搜索树
使用递归思想，总是选择中间位置左边的数字作为根节点，根节点的下标为 mid=(left+right)/2，递归求根节点的左右子节点

4. 验证二叉搜索树
迭代：使用中序遍历思想，判断pop出的当前节点值是否大于前一个节点的值，如果大于inorder=root.val,否则return false
递归：根节点的合法值域是 `(-∞, +∞)`，无边界限制；
       递归左子树收缩右边界，递归右子树收缩左边界；
       每个节点必须严格在 `(lower, upper)` 范围内，且左右子树都合法。

5. 二叉搜索树中第K小的元素
使用层序遍历二叉搜索树，将每一层的最后一个节点值保存到res中

6. 二叉树展开为链表
使用前序遍历递归算法得到保存二叉树前序遍历序列的list，然后将里面的节点left赋值为null，right设为下一个节点

7. 从前序与中序遍历序列构造二叉树
使用哈希表存储中序序列中的[值-索引]映射，降低时间复杂度。定义递归函数myBuildTree(preLeft,preRight,inLeft,inRight),递归终止条件是preLeft>preRight，sizeLeftSubtree连接前序和中序的边界，是拆分左右子树的关键

8. 路径总和III
使用递归算法，pathSum遍历所有节点，把每个节点当做路径的起点。rootSum从当前起点出发，向下遍历所有路径，统计和为targetSum的路径数。最终结果是所有起点的有效路径数之和。

9. 二叉树的最近公共祖先
从根节点往下递归找 p 和 q，自底向上传递 “找没找到” 的信号，哪个节点最先发现 p 和 q 分别在自己的左右两边，或者自己就是其中一个且另一个在自己子树里，这个节点就是最近公共祖先

10. 二叉树中的最大路径和
定义递归函数maxGain

# 回溯
1. 子集
使用二进制迭代方法，每一个子集可以对应一个长度为 n 的 0/1 序列，两层for循环，外层循环从0到1<<n,内层循环从0到n

2. 电话号码的字母组合
先建立一个字母数字映射表phoneMap，再定义一个backtrack递归函数，递归终止条件是处理完所有数字，拼接完成一个完整组合。这个算法通过回溯法递归遍历数字串的每一位，对每位数字对应的每个字母依次做 “选择 - 递归处理下一位 - 回溯撤销选择” 的操作，当处理完所有数字时，将当前拼接的字母组合存入结果集，最终得到所有合法的字母组合。

3. 组合总和

4. 括号生成

5. 单词搜索
6. 分割回文串

# 二分查找
1. 搜索插入位置
2. 搜索二维矩阵
3. 在排序数组中查找元素的第一个和最后一个位置
4. 搜索旋转排序数组
5. 寻找旋转排序数组中的最小值
# 栈
1. 最小栈
2. 字符串解码
3. 每日温度
4. 柱状图中最大的矩形
# 堆
1. 数组中的第K个最大元素
2. 前K个高频元素
3. 数据流的中位数