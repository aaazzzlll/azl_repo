# 二叉树

1. 二叉树的直径
递归：使用ans全局记录所有路径中节点数的最大值，初始值为1。递归函数返回值是Node子树的深度，题目要求的是边数，最终结果是ans-1

2. 二叉树的层序遍历
使用res数组保存结果，queue搭配while循环，每进行一次循环都是对当前层的节点进行遍历。
在while循环内部使用for循环，每取出一个节点就往队列中添加他的左右子节点（存在则添加，不存在不添加），同时将该节点的值push到`res[res.length-1]`中

3. 将有序数组转换为二叉搜索树
使用递归思想，总是选择中间位置左边的数字作为根节点，根节点的下标为 mid=(left+right)/2，递归求根节点的左右子节点

4. 验证二叉搜索树
迭代：使用中序遍历思想，判断pop出的当前节点值是否大于前一个节点的值，如果大于inorder=root.val,否则return false
递归：根节点的合法值域是 `(-∞, +∞)`，无边界限制；
       递归左子树收缩右边界，递归右子树收缩左边界；
       每个节点必须严格在 `(lower, upper)` 范围内，且左右子树都合法。

5. 二叉搜索树中第K小的元素
使用层序遍历二叉搜索树，将每一层的最后一个节点值保存到res中

6. 二叉树展开为链表
使用前序遍历递归算法得到保存二叉树前序遍历序列的list，然后将里面的节点left赋值为null，right设为下一个节点

7. 从前序与中序遍历序列构造二叉树
使用哈希表存储中序序列中的`[值-索引]`映射，降低时间复杂度。定义递归函数myBuildTree(preLeft,preRight,inLeft,inRight),递归终止条件是preLeft>preRight，sizeLeftSubtree连接前序和中序的边界，是拆分左右子树的关键

8. 路径总和III
使用递归算法，pathSum遍历所有节点，把每个节点当做路径的起点。rootSum从当前起点出发，向下遍历所有路径，统计和为targetSum的路径数。最终结果是所有起点的有效路径数之和。

9. 二叉树的最近公共祖先
从根节点往下递归找 p 和 q，自底向上传递 “找没找到” 的信号，哪个节点最先发现 p 和 q 分别在自己的左右两边，或者自己就是其中一个且另一个在自己子树里，这个节点就是最近公共祖先

10. 二叉树中的最大路径和
定义递归函数maxGain，递归计算每个节点的贡献值（舍弃负值）；以每个节点为顶点，计算 “左右贡献 + 节点值” 的路径和，更新全局最大值；贡献值供父节点拼接，顶点路径和用于更新全局最大值；

# 回溯
- 回溯问题核心：「定义结果集 → 回溯函数（终止条件 + 决策分支 + 选→递归→回溯）→ 初始调用」

1. 子集
使用二进制迭代方法，每一个子集可以对应一个长度为 n 的 0/1 序列，两层for循环，外层循环从0到1<<n,内层循环从0到n

2. 电话号码的字母组合
先建立一个字母数字映射表phoneMap，再定义一个backtrack递归函数，递归终止条件是处理完所有数字，拼接完成一个完整组合。这个算法通过回溯法递归遍历数字串的每一位，对每位数字对应的每个字母依次做 “选择 - 递归处理下一位 - 回溯撤销选择” 的操作，当处理完所有数字时，将当前拼接的字母组合存入结果集，最终得到所有合法的字母组合。

3. 组合总和
递归终止：遍历完元素（index等于candidates.length）或找到有效组合（target等于0）； 
决策1：不选当前元素，递归下一个下标；
决策2：若当前元素可选（剩余target≥元素值），选取后递归同一下标（支持重复选）；  

4. 括号生成
通过递归依次添加左/右括号，遵循“左括号不超过n，右括号不超过左括号“的规则，只生成合法的中间状态，直到字符串长度达到2n

5. 单词搜索
通过 DFS 从矩阵每个位置出发，按上下左右方向递归匹配单词字符，用‘#’原地标记访问状态，匹配成功则返回，失败则回溯恢复字符，遍历所有起点后无匹配则返回 false。
递归函数dfs，递归返回false：i，j越界，矩阵当前字符与目标当前字符不匹配；递归返回true：匹配到最后一个字符

6. 分割回文串
第一步：动态规划预处理回文子串，使用f`[i][j]`表示字符串s中下标从i到j的子串是否为回文串。初始化全部设置为true，i>j时为虚拟边界（无实际子串），约定为 true，目的是简化递推逻辑，避免特殊处理短子串；遍历时i从n-1到0，保证计算 `f[i][j]` 时，`f[i+1][j-1]` 已经计算完成
第二步：递归函数dfs(i)，表示从字符串下标i开始，枚举所有合法的分割方案。终止条件：`i===n` 表示已经分割完毕，将当前路径加入结果数组；j从i到n-1遍历，只选择`f[i][j]=true`的分割点，选择 `s[i...j]` 加入路径，递归处理 `j+1`，递归返回后撤销选择（`path.pop()`），尝试下一个分割点。
7. N皇后

# 二分查找
1. 搜索插入位置
mid=left+Math.floor((right-left)/2)  避免left+right溢出
想 “找存在性”→ 用 `left <= right`；
想 “找位置（插入 / 边界）”→ 用 `left < right`，让范围收敛到单个位置，后续判断更简单。
此处使用`left < right`，当测试用例是单元素数组时就不会进入循环，所以在最后的return判断中必须写的是`nums[left]<target?left+1:left` 

2. 搜索二维矩阵
使用两次二分查找，第一次二分查找找到最后一个首列元素 ≤ target 的行（循环结束后 `right` 即为目标行下标）；在找到的目标行内，用标准二分查找判断 target 是否存在；若目标行下标 `temp < 0`（所有行首列都 > target），直接返回 false

3. 在排序数组中查找元素的第一个和最后一个位置
使用两次二分查找，第一次查找找到 `nums[mid] === target` 时，不立即返回，而是将 `right = mid - 1` 继续向左遍历，确保找到最左侧的匹配值；重置边界后，找到 `nums[mid] === target` 时，将 `left = mid + 1` 继续向右遍历，确保找到最右侧的匹配值

4. 搜索旋转排序数组
二分查找时先通过 `nums [0] `和 `nums [mid]` 的大小关系（此处需要使用<=)判断 mid 所在的左 / 右有序区间，再在有序区间内判断目标值是否存在，从而收缩查找边界，最终找到目标值下标或返回 - 1
需要额外判断边界条件`nums.length===0`和`nums.length===1`

5. 寻找旋转排序数组中的最小值
通过二分查找，对比中间值 `nums [mid]` 和右边界值 `nums [right]`，若 `nums [mid]` 更小则最小值在左半区（收缩右边界到 mid），否则最小值在右半区（收缩左边界到 mid+1），最终收敛到 left=right 的位置即为最小值下标

6. 寻找两个正序数组的中位数

# 栈
1. 有效的括号
先通过字符串长度奇偶性快速排除无效情况，再利用栈的后进先出特性，左括号入栈、右括号校验栈顶是否为对应左括号（匹配则出栈，不匹配则直接返回 false），最终栈空则括号有效。
用 `Map` 存储「右括号 → 对应左括号」的映射（如 `)` 对应 `(`），目的是遍历到右括号时，能快速找到它需要匹配的左括号

2. 最小栈
用主栈存元素、辅助栈同步存 “当前栈最小值”，让 `getMin` 从 O (n) 优化到 O (1)，辅助栈初始值是Infinity；
辅助栈与主栈 “同进同出”，栈顶始终对应当前主栈的最小值；
注意不要把this写掉了

3. 字符串解码
使用双栈法，分别存储重复次数和括号前的前缀字符串，遇到数字就累计构建，遇到左括号保存当前num和current到对应的栈中，并重置num和current，遇到右括号就将数字栈栈顶数字取出，将前缀字符串栈栈顶的字符串取出，使用temp保存需要重复的字符串部分，使用for循环将temp拼接到前缀字符串后面

4. 每日温度

5. 柱状图中最大的矩形
# 堆
1. 数组中的第K个最大元素
2. 前K个高频元素
3. 数据流的中位数

# 动态规划
1. 最长有效括号
`dp[i]`表示以i下标结尾的有效子串的长度，所以结尾如果是'('，就不用处理。结尾如果是')',只有两种情况会更新答案：  
1.`s[i-1]`是'('，那么它们俩凑成一对，返回`dp[i - 2] + 2`。  
2.`s[i-1]`是')'，要想成功匹配，需要在i-1结尾的有效子串（长度为`dp[i-1]`）前面找到一个'(',该位置就是`i-dp[i-1]-1`。当然还要算上更早之前的有效长度`dp[i - dp[i - 1] - 2]`  
注意：这里所有的下标索引操作，都需要判断是否合法（>=0），只有合法才能操作，不合法就设为0